---
title: Anthropicの効率的なコンテキストエンジニアリングのガイドのメモ
tag: other
pubDate: 2025/10/01
---

[Effective context engineering for AI agents](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)を読んだ上での雑記。

（Written with GPT5）

## テーマと前提

* テーマは「コンテキストという有限資源をどう設計し、最小トークンで望む挙動を引き出すか」
  * コンテキストはLLMの推論時に渡す全トークン集合で、システム指示や履歴、外部データ、ツール結果を含む
  * ポイントは「最小の高シグナルトークン（high-signal tokens）」を選び続ける反復的なキュレーション
    * 期待する挙動の実現確率を最大化するうえで、情報価値が高いトークン群  
* 背景となる観察

  * トークンが増えるほど参照精度が徐々に落ちる現象があり、注意予算（Attension Budget）は有限
  * 長い文脈では関連性の低下や混乱が生じやすく、意図的な取捨選択が必須

## コンテキスト設計とプロンプト設計の違い

* プロンプト設計

  * 指示文の書き方や並べ方に焦点
  * 主にシステムプロンプトの改善で振る舞いを微調整
* コンテキスト設計

  * モデルに渡す情報集合の最適化に焦点
  * 対象要素

    * システムプロンプトの構成と高度
    * ツールとその入出力の設計
    * Few-shotの選定
    * メッセージ履歴と外部データの扱い
  * ねらい

    * 各ターンで「何を入れ、何を省くか」を決める反復プロセスを確立

## 効くシステムプロンプトの「高度」

* よくある両極端

  * if-else的に細かい規則を詰め込み壊れやすくなる
  * ふわっとした一般論だけで具体的な手がかりがない
* 推奨スタンス

  * 具体性と柔軟性のバランスを取り、必要十分な情報だけを明確に入れる
  * セクション分割や軽量マークアップで役割をはっきりさせる

    * 背景情報
    * 指示
    * ツールの使い分け指針
    * 期待する出力説明
* 運用の勘所

  * まず最小構成で高性能モデルを試し、失敗モード（failure modes）を見て段階的に指示や例を追加する

## ツール設計と返却の最適化

* ツールは情報空間へのインターフェース

  * 役割が重複しない自明な線引きを行い、どの場面でどれを使うかを曖昧にしない
  * 入力パラメータは誤読しにくく、モデルの得意さに沿う記述にする
* 返却データの方針

  * トークン効率を最優先し、本文ではなく要約や識別子を中心に返す
  * エージェントの行動を効率化する形を心がける
* 失敗パターン

  * 機能を盛り込みすぎたツール群で選択の分岐が増え、判断ミスや冗長探索を招く

## Few-shotと例示の扱い

* 方針

  * 増やすより選ぶ、境界を含む多様な正準例を少数精鋭で用意
  * 規則を事細かに列挙するより、望ましい出力の具体的サンプルで学習させる
* 期待する効果

  * 余計な規則の羅列を避けつつ、モデルに強いヒューリスティクスを与える

## ランタイムの文脈取得とエージェント探索

* 事前取得中心からのシフト

  * 多くのアプリは埋め込み検索などの事前取得を使うが、エージェント化が進むほどJIT取得の重要性が増す
* JIT取得の考え方

  * ファイルパスや保存済みクエリ、URLなどの軽量参照を保持し、必要時にツールで本文を取りに行く
  * 大量データはBashのheadやtailのような原始操作で断片的に観察し、全体を一気に読み込まない
* メタデータの活用

  * パスやフォルダ階層、命名、タイムスタンプが強いシグナルになる

    * `tests`以下のファイルは意図や役割が明確に推測できる
    * サイズや更新時刻で優先度やコストを見積もれる
* プログレッシブな開示

  * 探索で得た気づきを次の一手に反映し、必要最小限だけ作業メモリに残す
  * 追加の情報は外部ノートへ書き出し、後で必要な分だけ戻す
* ハイブリッド戦略

  * 一部の基盤情報は先置きしつつ、詳細はJITで段階的に取得
  * 自律度の最適点はタスク依存で決まり、用途によって先読みと探索の配分を変える

## 長時間タスクに効く3つのテクニック

* コンパクション

  * コンテキスト上限が近づいたら履歴を高忠実に要約し、新しいウィンドウをその要約から再開
  * 残すべきは設計判断や未解決事項などの本質情報で、冗長なツール出力は除去
  * まず高リコールで過不足なく拾い、次に高精度化で余分を削る
* 構造化ノート（Structured note-taking）

  * コンテキスト外にノートを永続化し、後で必要な要点だけを再投入
  * TODOや決定記録、依存関係を継続的に管理し、長時間の連続作業で一貫性を維持
* サブエージェント構成

  * 役割ごとに専用エージェントを分け、詳細探索は各サブが担当
  * 親エージェントは集約と意思決定に集中し、サブからは凝縮サマリだけを受け取る
  * 分割により関心の分離が明確になり、各ウィンドウを小さくクリーンに保てる

## 実装時のチェックポイント

* システムプロンプト

  * 背景と指示、ツール指針、出力形式をセクション化し、過不足ない高度で書く
  * 最小構成で評価し、失敗モードに応じて段階的に補強
* ツール

  * 役割が重ならない設計にし、返却は要約と識別子中心でトークン効率を担保
  * 増やす基準と廃止基準を明確にし、保守容易性を確保
* Few-shot

  * 多様な正準例を少数選び、出力フォーマットは本番と一致させる
* 取得戦略

  * 事前取得とJIT取得をタスク特性に合わせて配合
  * 参照メタデータで候補を先に絞り、本文読み込みは段階的に行う
* 長時間タスク

  * コンパクションのプロンプトを失敗事例でチューニング
  * 構造化ノートの粒度と書き戻しルールを固定
  * サブエージェントの境界と合流フォーマットを明示

## まとめ

* コンテキストは有限の注意予算であり、増やすよりも「選ぶ」「捨てる」を設計に組み込むのが要点

  * システムプロンプトは必要十分を明確に、ツールは役割を明快に、Few-shotは少数精鋭で
  * 事前取得とJITを組み合わせ、メタデータと段階取得で無駄を減らす
  * 長時間タスクではコンパクション、構造化ノート、サブエージェントを併用して一貫性を維持

## refs

* [Effective context engineering for AI agents](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)
